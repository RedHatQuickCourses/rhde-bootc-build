:time_estimate: 5

= Lab: Build and Test Bootc Containers

_Estimated reading time: *{time_estimate} minutes*._

Objective::
Create containerfiles and build bootc container images for RHEL for edge systems

WARNING: Work in progress

== PROVISORY OUTLINE

* Mention the possibility of using Buildah and any other tool capable of producing OCI containers.
* If we stick to “trivial” bootc containers, it’ll be hard for learners to internalize how they’re different from regular container images. Because trivial bootc container images “just work” with podman, including most privileged containers, as they are on a similar or same RHEL kernel, it’s hard to see that this is NOT the general case.
* Build a bootc container image and run it with podman, to show that the kernel and other things inside the image are inactive because it is not intended to be run that way.
* Find something obvious and simple that behaves differently between running from podman and from booting a VM, but that looks “working” at a first glance.
** Use a RHEL9 bootc container on a RHEL10 host to make it clear that the kernel on the bootc container is not active?
** Use a FIPS-enabled container, in a non-FIPS host, to show that it’s not FIPS when run from podman?
** SELinux labels? Put web content on /var/something, set the apache documentroot to there, and forget to relabel /var/something. It works from podman but not after bootc install, right. Example.

== Before you Begin

You need a _development machine_ running RHEL, to which you have access using an unprivileged user account.

These instructions were tested on RHEL 10.0 but should work with minimal or no change on and newer and older RHEL releases, since 9.6.

If you are using the course classroom, you will log in on the `workstation` VM as the user `student` with password `student`. If not, please adapt the instructions to your test environment.

Make sure you verified your test environment by following the xref:ch1-intro:s3-prereqs-lab.adoc[first lab] of this course.

== Instructions

1. Prepare to start this activity by cloning the sample code repository and loggin in the private registry.

.. Create a local clone of the sample code repository of this course, and make it your working directory.
+
[source,subs="verbatim,quotes"]
--
$ *git clone https://github.com/RedHatQuickCourses/rhde-bootc-samples.git*
Cloning into 'rhde-bootc-samples'...
...
$ *cd rhde-bootc-samples*
--

.. If needed, login to your private registry.
+
[source,subs="verbatim,quotes"]
--
$ *podman login -u student -p redhat registry.lab.example.com:5000*
Login Succeeded!
--

2. Inspect the Containerfile for a single-page web applicaiton, which uses the Apache Web Server to host your HTML and JavaScript code.

.. Enter the directory `httpd-bootc`.
+
[source,subs="verbatim,quotes"]
--
$ *cd httpd-bootc*
--

.. Review the Cointainerfile.
It installs the `httpd` package and enables the `httpd` service, them adds the files of our singe-page web application.
+
[source,subs="verbatim"]
--
include::1@samples:httpd-bootc:example$Containerfile[]
--
+
NOTE: The container file does NOT define any of the usual container image metadata, such as `ENV`, `USER`, or `VOLUME`.
It also does not define neither an `ENTRYPOINT` nor a `CMD`.

3. Build and test the bootc container image for your single-page web application.

.. Build your bootc container image.
+
[source,subs="verbatim,quotes"]
--
$ *podman build -t httpd-bootc .*
...
Successfully tagged localhost/httpd-bootc:latest
--
+
WARNING: The last argument of the `podman build` command above is a dot, for the current directory.

.. Run the bootc container image as a rootless application container.
+
Because regular users cannot access the standard HTTP port (80), configure port-forwarding from a higher port number.
+
[source,subs="verbatim,quotes"]
--
$ *podman run -d -p 8080:80 --name httpd httpd-bootc*
--

.. Use either a web browser or the Curl utility to view the mock of our single-page web application.
+
[source,subs="verbatim,quotes"]
--
$ *curl 127.0.0.1:8080*
This would be the HTML and Javascrit code of you single-page web application.
--

.. Verify that your bootc contrainer image inherits the `containers.bootc` label key from the bootc base image.
+
[source,subs="verbatim,quotes"]
--
$ *skopeo inspect --format '{{ index .Labels "containers.bootc" }}' containers-storage:localhost/httpd-bootc*
1
--

.. Stop and delete your bootc container.
+
[source,subs="verbatim,quotes"]
--
$ *podman stop httpd*
httpd
$ *podman rm httpd*
httpd
--

4. If you feel that our first bootc container could work exactly the same way as a simple application container, you are right.
Let's compare our bootc container with a regular application container for the same application.

.. Change to the `httpd-ubi` directory
+
[source,subs="verbatim,quotes"]
--
$ *cd ../httpd-ubi*
--

.. The Cointainerfile uses the standard UBI image, so it must install the `systemd` package and start the Systemd daemon as its `ENTRYPOINT`.
+
[source,subs="verbatim"]
--
include::1@samples:httpd-ubi:example$Containerfile[]
--

.. This Containerfile is NOT a good example of a static web application.
It violates many recommendations for application containers, among them:
+
... It runs more processes than it requires.
It should start the Apache Web Server as its `ENTRYPOINT`
+
... It does NOT send logs to the standard output and error.
+
... It runs as `root`m because it does not set a `USER`.
+
... It listens to a privileged TCP port (80), as per the default Apache Web Server configuration.
+
NOTE: Providing a good example of a Containerfile for a web application is outside the scope of this course.

.. Build and run the application container.
+
[source,subs="verbatim,quotes"]
--
$ *podman build -t httpd-ubi .*
...
Successfully tagged localhost/httpd-ubi:latest
$ *podman run -d -p 8080:80 --name httpd httpd-ubi*
...
$ *curl 127.0.0.1:8080*
This would be the HTML and Javascrit code of you single-page web application.
--

.. Delete your application container.
+
[source,subs="verbatim,quotes"]
--
$ *podman stop httpd*
httpd
$ *podman rm httpd*
httpd
--

5. Because the HTML and JavaScript code of a singe-page web app is NOT supposed to be managed as data, improve your Containerfile to host the code in `/usr` instead of `/var`.

.. Change to the `webapp-bootc` directory.
+
[source,subs="verbatim,quotes"]
--
$ *cd ../webapp-bootc*
--

.. Review its Cointainerfile.
It changes the Apache Web Server configuration to serve files from `/usr/webapp` instead of `/var/www`

+
[source,subs="verbatim"]
--
include::1@samples:webapp-bootc:example$Containerfile[]
--
WARNING: That improved bootc container image has a serious issue, that you will NOT be able to see by simple testing using Podman.
If you can spot what the issue is, do NOT fix it yet.
We will see, later in this course, how to test the bootc image in a way that surfaces that kind of issue.

.. Build your improved bootc container image.
+
[source,subs="verbatim,quotes"]
--
$ *podman build -t webapp-bootc .*
...
Successfully tagged localhost/webapp-bootc:latest
--

.. Run your improved bootc container image as a rootless application container.
+
[source,subs="verbatim,quotes"]
--
$ *podman run -d -p 8080:80 --name webapp webapp-bootc*
--

.. Use either a web browser or the Curl utility to view the mock of our single-page web application.
+
[source,subs="verbatim,quotes"]
--
$ *curl 127.0.0.1:8080*
This would be the HTML and Javascrit code of you single-page web application.
--

.. Delete your test container.
+
[source,subs="verbatim,quotes"]
--
$ *podman stop webapp*
webapp
$ *podman rm webapp*
webapp
--

== What's next

The next section presents some strategies for configuring systems from a bootc container image.