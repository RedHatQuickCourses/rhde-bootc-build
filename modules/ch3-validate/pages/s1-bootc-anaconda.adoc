:time_estimate: 11

= Test Bootc Containers With Anaconda

_Estimated reading time: *{time_estimate} minutes*._

Objective::
Introduce the bootc utility and how the RHEL installer (Anaconda) can use a bootc container image as its installation source.

WARNING: Not Started

== PROVISORY OUTLINE

* Bootc is inside bootc containers and involved at deployment, updates, and other moments
* Using bootc install to a disk or filesystem
* Introduction to libvirt and macadm
* Mention Podman Machine/Podman Desktop tools for Windows and Mac developers

== How to install image mode systems

Previous chapters demonstrate the need to perform system testing of bootc container images.
You just cannot validate that all system settings in a bootc container image are applied and work as intended using a container engine such as Podman.

To perform system testing, you must install an image mode system, and them boot the system.
There are multiple ways of installing an image mode system, among them:

. Use the standard RHEL installation media and provide a custom kickstart configuration that references a bootc container image as its installation source.

. Start from a system already running RHEL and run the Bootc utility, from a bootc container image, to install the system, effectivelly overwriting its current RHEL installation with a booc container image.

. Use the Bootc Image Builder tool to build either a custom installation or a custom cloud image which embeds a pre-installed bootc container image.

In this chapter, we use option (1) above, and in the next chapter, we use option (2), as two ways of performing quick testing of a bootc container image.
A follow-up course will teach option (3) as the recommended way of deploying edge systems in production.

Before we teach the specifics of how to craft and run a kickstart file that uses a bootc container image, let's consider how much configurations, or how little, should actually be in a bootc container or left to be performed after installing an image mode systems.

== Day-0 and Day-1 System Configuration

Bootc container images open the possibily for including, in a system image, many configuration settings that would typically be performed at day-2 in a package mode system or, as some would say, at day-1, right after performing installation.

This means not only a faster time to install an image mode system, compared to a package mode system, but also a faster time to configure it and be ready to onboard its users.

Some organizations perform such day-1 configurations using system installation scripting tools, for example Anaconda kickstart and Cloud-init. 
Others perform such configuration using automation technologies, such as Red Hat Ansible Automation Platform.

The need for performing day-1 configurations does NOT disappear with image mode systems.
Sure, you may include a large set of configurationsin a system image, but there are usually something which must be different between devices or between edge sites.

Managing a large number of images, to account for those variations, may become a challenge.
It may be easier to produce a golden system image, which is shared by a large number of edge devices and sites, and perform minimal day-1 configuration after (or during) installation.

=== Secrets management and device onboarding

Another concern with including system and application configurations in a system images come from potential risk scenarios related to secrets management, such as:

* A a removable media, used to provision edge devices, was stolen or lost, and it includes credentials to access line-of-business (LOB) databases or to perform payments.
* A rogue device is plugged into network of an edge site, installed as a genuine device, and them taken off-site to access its system disk and grab the credentials stored there.

Notice that having such credentials, or secrets, outside of a system image, but inside custom installation media, such as within a kickstart script, present similar risks.

To manage such risks, many organizations employ secure and auditable _onboarding_ processes, which completes the day-1 configuration of edge devices by adding device and site specific IDs and installing secrets for acessing applications and other resources in either the edge site or around the corporate network.

You can implement effective onboarding processes with traditional automation tools, and maybe you already have mature processes which you use on branch offices and other "larger" near edge sites, and it is OK attempting to scale them to far edge scenarios. 

Alternatively there are alternatives technologies and tools, designed to address the challenges of provisioning and onboarding edge devices at scale and in a secure way. Among them:

* The FIDO Device Onboarding (FDO) standard
* The Red Hat Edge Manager product, based on the Flightctl open source project

These technologies also consider the challenges of dealing with with hundreds or thousands of edge devices, as opposed to dozen or servers, and dealing with lower network bandwith or higher latency than in typical data centers and office buildings.

=== Secrets in bootc container images

In summary, the general advice is to avoid having secrets embedded in a bootc container image, and use instead some day-1 configuration approach to add them.
Consider that user passwords, for log in in a system console, and SSH keys, for remote access to a system, are also secrets.

Some secrets are designed to be public and could be safely embedded into a system image, for example a CA certificate to access corporate servers without disabling TLS validation.

Some other secrets may require careful assessments of the risks, for example credentials to download container images from a private registry:

* If such images contain corporate intelectual property, you may handle these credentials as sensitive secrets.

* If such images are just mirrors of publicly available images, you may embed these credentials on your system images.

* If your registry contains a mix of public and privage images, you may need different credentials for each set of images, and audit access permissions granted to each of them.

WARNING: In this course, we will provide secrets using kickstart files, for simplicity.
Be aware it may not be a secure alternative for your real-world scenarios.

Also consider the different secrets you may require at bootc image build time, versus the secrets you require at runtime, on actual edge devices, and during system or integration testing.

== Anaconda and bootc

The standard RHEL installer program, called Anaconda, is capable of installing both package mode and image mode systems:

* In the first case, the installation source is a DNF repository which provides RHEL packages.

* In the second case, the insallation source is a bootc container image.

When Anaconda uses a bootc container image, it runs bootc to install the kernel, bootloader, and other settings from the container image.
Before running bootc, Anaconda performs any required preparation, for example partitioning disks and initializing network, and also performs any day-1 configuration selected by the user, such as setting a root password.

Current releases of Anaconda default to package mode systems, using DNF repositories from either Red Hat, over the Internet, or from the RHEL installation media itself.
The difference between the two RHEL installation medias, the smaller "standard" one (which used to be called the _netinstall_ media) and the larger one, which allows off-line installation, is just the presense of such repository on the media itself.

Both RHEL installation medias contain a complete RHEL system, which boots and autoruns Anaconda, which in turn starts a set of interactive screens for configuring package selection, destination disk, partitioning, network configuration, and initial users.

Kickstart scripts automate those screens, enabling fully automated and even headless installation of RHEL, and also provide access to Anaconda features which may not be available on its interactive screens.

Unfortunatelly, *you CANNOT use the interactive mode of Anaconda to select a bootc container image as its installation source*.
You MUST provide a kickstart script to install an image mode system.
It does not need to be a complete kickstart script for unattended installation, but it probably will be, for edge devices.
So you can provide a kickstart file which selects a bootc container image and still use interactive screens to partition disks and set a root password.

Kickstart scripts can also embed custom scripts which they run before starting installation (in a `%pre` block) and after completing the insallation, but before rebooting the system (in a `%post` block).
These capabilities will be handly to perform system testing of bootc container images without requiring custom installation media nor an OCI container registry server.

== Local VMs on RHEL

The native local hypervidor on RHEL systems is a stack composed of three parts:

KVM::
A kernel module which provides hardware-assisted virtualization of CPUs, memory, and system busses.

QEMU::
A software emulator which provides all other virtual hardware required to create an actual VM, for example video, disk, and network devices.
QEMU is also capable of emulating a complete system, for example to emulare an ARM CPU on an Intel system.

Libvirt::
A management layer which orchestrates KVM, QEMU, and other Linux kernel features to ease creation and management of local VMs.

A number of tools from RHEL, for example the Cockpit web management interface, and the `virt-install` command, use libvirt to mange local VMs based on KVM and QEMU.

You do NOT requite a RHEL system, nor a Linux system with libvirt, to perform system testing of bootc container images.
You can use the native hypervisor of your Windows or MacOS laptop, but this course does not provide instructions for doing it.

=== Libvirt developer features

Libvirt is the single host management layer at the foundation of many of enterprise virtualization tools, such as OpenShift Virtualization and Red Hat OpenStack.
It provides many advanced capabilities at its API level, which require dealing with XML configuration files.

For system testing of bootc container images, we are more interested on libvirt features designed to support a developer inner loop, such as:

Session interface::
Enables managing local VMs in _rootless_ mode.
Yes, you can run VMs in Linux without `sudo`.

User mode networking::
Avoids the need for privileged access to configure host networking, such as virtual NICs and bridge devices.
It is the same technology which enables network connections to rootless containers with Podman.

Direct kernel loading::
Bypass the boot loader in a disk image or device, and loads a Linux kernel and initial ram disk directly from a local or remote directory.

Virtio devices backed by host directories::
Enables sharing files with a VM without creation of disk images, and without requiring privileged access for managing loopback devices.

These features are commonly used by developers and platform engineers, running desktop Linux distributions such as Fedora, to manage RHEL VMs for testing.

=== Unnatended VM creation with the virt-install comand

Typically, a RHEL administrator would provide kickstart scripts in an HTTP server, and use the interactive features of Grub to provide kernel arguments that reference that kickstart file.
A similar process is normally used to provision RHEL systems using network boot, either PXE or UEFI.

It is also somewhat common that RHEL administrators use the `xorriso` tool suite, such as the `mkksiso` command, to produce a custom RHEL installation media which already embeds a custom kickstart script and third-party package repositories, so they do NOT need to enter Grub's interactive screens.

But, using the features mentioned in the previous session, we can perform a quicker workflow, which uses a kickstart script in a local directory, and a bootc container image also in a local directory:

* A virtio device provides the kickstart script and bootc container image.
* Direct kernel loading provides kernel commands that make Anaconda use the kickstart script.
* The session interface and user mode networking elliminate the need for privileged access (`sudo`).

You can also give the kernel more options which enable a serial, text console, so you do not need a graphical desktop to create a VM and follow its boot screens.
This way, you can create test VMs over an SSH connection or as part of a CI/CD pipeline and save its boot messages in a text file for troubleshooting.

These options are not yet available from graphical front-ends to libvirt, but they are available from the `virt-install` command, which we use in the next activity.

After you create your test VM, you can manage it using any libvirt front-end, for example the `virsh` command or Cockpit.

== What's Next

The next activity uses the standard RHEL installation media to create a libvirt VM which boots from the contents of a bootc container image.
This is one way you can perform comprehensive tests of bootc container images, before you publish it for use in production systems.
