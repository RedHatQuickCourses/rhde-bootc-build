:time_estimate: 22

= Provision and Manage Edge Devices with Red Hat

_Estimated reading time: *{time_estimate} minutes*._

Objective::
Introduction to edge devices, Red Hat Device Edge, and image mode for RHEL

WARNING: Work in progress

== What is Red Hat Device Edge

Red Hat Device Edge is a software and support subscription that bundles three components:

. Red Hat Enterprise Linux (RHEL), which includes a feature set known as *RHEL for edge*.
. Red Hat build of MicroShift.
. Red Hat Ansible Automation Platform.

image::s1-devices-fig-1.svg[title="Components of Red Hat Device Edge"]

Most of these components can be purchased as part of other subscriptions from Red Hat.
For example, RHEL and Ansible are frequently purchased as their own subscriptions, instead of as part of a bundle.
Red Hat Device Edge brings in a pricing and suportability scope that is more aligned with the characteristics of edge devices.

For example, the per-CPU and per-machine cost of running RHEL with a Red Hat Edge subscription is lower than the cost of running RHEL with a Red Hat Enterprise Linux subscription, because the first targets small edge devices, with a single CPU socket and a few GB of memory, while the second targets large servers in a data center, with multiple CPU sockets, each socket with a large number of cores, and hundres of GB of memory.

You may purchase Red Hat Device Edge to use the RHEL for edge features in an army of small edge devices, but you could also find out that your edge machines are "large" and requires a different subscription to get RHEL and other Red Hat products.
In both cases, you get the full feature set of RHEL.

Red Hat Device Edge is NOT a different edition of RHEL, nor a subset of RHEL.
Many features of RHEL, which were developed originally for the requirements of edge scenarios, are also very valuable in data center scenarios.
Oh the other had, features from RHEL that you may be used to rely on data center scenarios are also useful in edge scenarios, bringing in more standardization and ultimately reducing the effort and cost of managing edge devices.

=== What is image mode for RHEL

https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux-10/image-mode[Image mode] for Red Hat Enterprise Linux enables you to manage your OS with the same container tools and workflows as applications, creating a consistent experience and common language across teams.

Provisioning and updating RHEL systems based on image mode is faster and more reliable than with the traditional approach of dealing with RPM packages one at a time.
The traditional approach is now called _package mode_ for RHEL.

Edge devices benefit from the consistency, reliability, and ease of rolling back updates to RHEL systems using image mode.
Image mode also enables easy repurposing of edge devices, by loading into them different system images.

It is also easier for Operational Technology (OT) professionals, who are typically NOT Linux sysadmins, to perform device provisioning and updates using image mode for RHEL on _far edge_ sites than with package mode for RHEL.

There are organizations with success using traditional RHEL provisioning and management worklows, based on package mode, on edge sites.
Especially on larger _near edge_ sites, which provide infrastructure comparable to a data center, with larger machines and "server rooms". 
As those organization replace legacy, single-purpose proprietary edge devices with newer, standards-based edge devices, they can adopt process and workflows based on _image mode_ alongside with their existing processes and workflows.

=== How image mode changes RHEL for edge?

The previous generation of RHEL for edge, based on the core technologies of the discontinued RHEL Atomic Host product, and included with RHEL 8 and 9, was based on the RPM-OStree technology.
It required a number of special-purpose tools and infrastructure, with a steep learning curve.
You can still use RHEL 10 to maintain system images based on RPM-OSTree for RHEL 8 and RHEL 9 systems.

The current generation of RHEL for edge, included with RHEL 9 (since 9.5) and RHEL 10, https://www.redhat.com/en/blog/what-image-mode-means-users-rhel-edge[replaces these special-purpose tools and infrastructure with the tools and infrastructure from the containers word].
This means your organization probably already have professionals with skill on those tools and a supporting infrastrucure is already in place.
Even if it does not, it is easier to hire professionals with container skills than with RPM-OSTree skills, and there are a large ecosystem of vendors providing and supporting infrastructure for building and managing Linux containers.

RPM-OStree was one approach to provision and manage RHEL devices using system images, which included both operating system and configurations, and possibly also applications, for an appliance experience.
Image mode is another approach to implement a similar philosophy and provides similar benefits.
It is basically a change of tools.

Other features from RHEL for edge, such as greenboot and kiosk mode, work with image mode as well, and some of them even with package mode.

Before we dive deeper into the workflows and tools required by image mode for RHEL, let's discuss how edge devices differ from servers in a data center and and what kind of edge devices you can provision and manage using RHEL.

== What is an edge device

Edge devices, sometimes called edge endpoints, edge gateways, and edge servers, come in varying shapes and forms.
For the purposes of this course, all of them are referred to as _edge devices_.

Some of edge devices look just like standard computers, maybe in a rugged and smaller form factory.
They could also take unique form factors which integrate sensors, servo-mechanisms, and other specialized peripherals in the same system board and might not look, from the outside, anything like a "personal computer" (PC).

image::s1-devices-fig-2.svg[title="Illustrative images of edge devices and traditional computers"]

Traditional edge devices were NOT capable of running a standard operating system like RHEL, and usually run an proprieraty operating system embeded into their firmware.
These edge devices usually connect to a more standard computer, an _edge gateway_, which mediates the communication between these specialized and single-purpose edge devices with the larger network and IT infrastructure of their edge sites and corporate headquarters.

More modern edge devices are built on the same fundamental architecture, processors, chipsets, and peripheral busses as a standard PC, thanks to the advancements of smart phones and ARM architectures.
These devices may be similar, regarding cost and power consuption, to traditional edge devices, but because they are able to run a standard operating system, they are multi-purpose devices which a potentially longer life span.

Some kinds of computers, such as mini-PCs, are blurring the line between a standard computer and an edge device.
Depending on their capabilities, they may be eligible for Red Hat Device Edge subscriptions, or they may require a Red Hat Enterprise Linux subscription.

=== Use cases for edge devices with Red Hat Device Edge

RHEL for edge is designed to support devices which are closer in hardware architecture to standard personal computers and servers. It benefits from the large ecosystem of software and hardware certified for RHEL and large pool of professionals skilled in Linux.

For example, you cannot run RHEL directly in most surveillance cameras. But you could run RHEL in edge devices that monitor the video feed from a surveillance camera (or from multiple cameras) to detect potential security threats and fire an alarm to call security or the police.

A similar edge device could use a video camera to perform quality control in a factory, identifying defective pieces and reducing the need for human inspection, and also rerouting the defective pieces for either disposal or recycling without manual intervention.

Now imagine that the same edge device controls a robotic arm with a spray gun: instead of being pre-programmed with a fixed path to paint only a pecific piece, known in advance, an edge device could adapt and optimize the paint process based on the specific piece it sees.

Each of the scenarios above requires some specialized hardware, but they are more about the application software which controls the hardware than about custom chips and peripherals.
Having a common and standard foundation for that software, based on Red Hat Device Edge, reduces the development and maintenance effort.

There are many more potential scenarios for edge devices than we can describe here.
Most times, edge devices co-exist with more traditional computers and applications on the same site.
For more information on the applicability of RHEL for Edge and Red Hat Device Edge to different edge scenarios, we invite you to explore https://www.redhat.com/en/products/edge/hatville[HatVille, the miniature city where edge computing comes to life].

Another set of factors to consider in assessing your edge device use case is the infrastructure available on an edge site.
Edge devices may exist by themselves, in a site where the owner has little control of anything, like a pick-up locker location or an ATM machine at a drugstore.
On the other hand, edge devices might exist in a location which has a server room, uninterruptible power supplies, and reasonable cooling, such as in a large department store.

image::s1-devices-fig-3.svg[title="Generic edge site with many classes of edge devices"]

The following table compares edge devices with more traditional computers to help you distinguish between scenarios of RHEL for edge versus a scenario for traditional RHEL.
Parts of it may become quickly outdated as hardware evolves and costs come down, so instead of focusing on fixed numbers, focus on relative differences and check the https://www.redhat.com/en/resources/red-hat-enterprise-linux-subscription-guide[RHEL Subscription Guide] or ask your Red Hat Account Manager for pricing and eligibility for the many edge and non-edge product SKUs.

[options="header",cols="1,1, 1"]  
|===
| RHEL for edge
| RHEL Workstation
| RHEL Server

| Mini PC, rugged mini-server, and many custom form factors
| Desktop, Tower, laptop, or mini PC
| Tower, rack-mounted, or blade enclosure

.^a| image::edge-device.png[]
.^a| image::pc.png[]
.^a| image::rack-server.png[]

| 1 CPU socket, 1 or 2 CPU cores
| 1 or 2 CPU sockets, 4 to 16 CPU cores each
| 2 to many CPU sockets, from dozens to hundreds of CPU cores

| 1.5 to 8 GB of memory
| 4 to 64 GB of memory
| Hundreds to thousands GB of memory

| Single purpose: Point-of-sales, industrial control, access control
| Multi-purpose: web browsing, spreadsheets, multimedia, etc
| Multi-purpose: databases, ERP, IT automation, etc

| Special-purpose peripherals: bar code readers, device actuators, temperature/humidity sensors, custom key panels, and so on
| Standard peripherals: monitors, qwerty keyboards, mouses, scanners, printers
| Standard peripherals: Ethernet NIC, NVMe cards

| Deployed on hazardous environments, exposed to dust, heat, electromagnetic fields, and heavy machinery
| Deployed on friendly office environments, with stabilized power supply and air-conditioning
| Deployed on friendly data center environments, with uninterruptible power supply and specialized cooling

| Exposed to end users, customers, and outsiders, sometimes in public areas
| Exposed to office employees, protected by corporate access controls
| Locked in server rooms

| Rely on minimal to no infrastructure on edge sites, such as DHCP servers and IP routers
| Depend on extensive infra-structure from corporate IT, such as identity managers, backup appliances, file servers, and remote control
| Depend on extensive infra-structure from corporate IT, such as automated management, certificate servers, CI/CD, storage arrays, and firewalls

| Deployed and maintained by Operational Technology (OT) staff
| Deployed and maintained by Information Technology (IT) staff
| Deployed and maintained by System Administrators (IT)
|===


== Image mode versus package mode

The main characteristic of RHEL for edge, from the point of view of a Systems Administrator, is the focus on image mode systems, while traditional RHEL server deployments are usually package mode systems.

image::s1-devices-fig-4.svg[title="RHEL systems with package mode versus image mode"]

There are two technologies which can create system images for RHEL systems:

RPM-OStree::
It uses OSTree commits as its system images, and requies specialized tooling to build such images, and management of specialized OSTree repository servers.
It is available for RHEL 8 and 9 system images.

Bootc::
It uses OCI container images as its system images, and can use any tooling capable of building and distributing standard OCI container images.
It is available for RHEL 9 and 10.

This course focuses on the second option.
If you need enablement on the first option, please refer to https://redhatquickcourses.github.io/rhde-build/[Building Red Hat Device Edge Images].

=== Day-1 and Day-2 with image mode for RHEL

Image mode systems are provisioned and updated from a single system image.
You do NOT install or update individual packages of the operating system, like you would do with package mode systems, using a package manager.

Package mode systems require extensive day-2 customizations, after initial provisioning, to perform tasks such as installing additional packages and editting system configuration files.

Image mode systems, on the other hand, assume that most day-2 customizations are already embedded in their the system image. This is consistent with the shift-left approaches popular among DevOps and cloud-native practitioners.

The following table compares common actions for deploying and managing traditional RHEL, or package mode for RHEL, with RHEL for edge systems using image mode for RHEL.

[options="header",cols="1,1"]  
|===
| RHEL for edge
| Traditional RHEL

| Image mode, using OCI container images based on the bootc technology as its system images.
| Package mode, using the DNF package manager and RPM packages.

| RHEL installer downloads and extracts a complete OCI container image at once.
| The RHEL installer downloads and installs multiple RPM packages, one by one.

| Download and deploy a complete system image, while retaining the previous system image unchanged.
You can keeping the previous system image after switching to the new system image, and rollback to it, if desired.
| Update individual RPM packages using DNF.
You might update some packages and not others, either on purpose, by mistake, or because some indivdual package could not be downloaded or applied.

| Easy to check the state of the entire system: it corresponds to one and only one of the available system images.
| Hard to track the state of a package-based system, as a whole: it could contain any permutation of all packages and versions available.

| Install all operating system components (and possibly applications too) at once, as part of the system image.
Can also install applications from OCI container images, after or during initial provisioning.
| Install individual operating system components and applications one by one, from individual RPM packages and optionaly from OCI container images.

| Embed operating system and application configuration files in the system image, and perform minimal local customization or edits, per-device or per-site, as a day-2 activity.
| Edit operating system and application configuration files one by one, as a day-2 activity, after initial system provisioning.

|===

When you create a RHEL cloud instance, for example using the standard RHEL AMI or Qcow2 cloud images, they provision package-based RHEL systems, which you manage on day-2 the same way as if you installed from the RHEL installation media.
But, with image mode for RHEL, you can create cloud images which provision systems from a bootc container image, no mater if your cloud instances are edge cloud instances or not.

Image mode for RHEL can also consume applications as OCI container images, and update those container images from container registries.
This is usually more manageable than RPM packages because there is an automatic rollback capability from Podman and Systemd, which is similar to Green Boot with operating system updates.
If you want, you can embed your application container images in your bootc container images, for an appliance experience, where the state of an edge device is determined uniquely by its current system image and nothing else.

When you think about customizations of an edge device, consider how much of it is actually per-device or per-site.
You may find that many, if not most, of the day-2 customizations you are used to performing in package-based systems could be included in a system image.

For example, the public key of your corporate certificate authority, for secure TLS communications, is a customization that applies to all your edge devices equally, in all sites.
But the IP address of a web proxy is probably different for each site and multiple devices on the same site require the same web proxy configuration.

It is your option to build site-specific system images, which embed customizations for each individual site, or build a single edge image for all edge sites, and apply the similar configurations to multiple devices in the same location.
In any case, you can use Ansible automation to apply or change site and device-specific customizations, similar to what you would do with package mode systems.
You just expect to have fewer customizations to apply using automation, because more of them are already done in the system image.

=== What is bootc

https://bootc-dev.github.io/bootc/[Bootc] is the utility which manages installing and updating image mode systems from OCI container images.
It is included as part of bootc container images, and it is usually run as a privileged container from those images.

Most of the time, developers and system administradors do NOT interact directly with the bootc utility.
It is included with a base bootc container image, and the process of building derived bootc container images looks just the same as the process for building derived application container images. 

=== What are booc container images

A system image for image mode systems is an OCI container image which includes a number of componentes not usually included with regular container images, among them:

* A Linux kernel and loadable modules
* An initial ram disk (initrd) and a boot loader (grub)
* The System Daemon (Systemd) and a number of privileged Systemd unit to manage hardware, networking, and system services
* The D-Bus system messaging middleware
* The bootc utility

We call those system images _bootc container images_ to differentiate them from regular OCI container images, which we call _application container images_.

IMPORTANT: It was common to refer to bootc container images as https://developers.redhat.com/articles/2024/09/24/bootc-getting-started-bootable-containers[bootable containers], but that term is misleading: no current firmware, hypervisor, or IaaS cloud provider is able to boot from an OCI container image.
So bootc container iamges are not actually bootable.

Typical OCI container images are designed to provide a single application, and include only the required userspace components required to support that application, such a programming language runtime and required dependency libraries.
Bootc container images are designed to provide a complete system, including its kernel mode components and possibly multiple applications, system services, and network services.

But, other than the fact that bootc container images are a lot bigger, they are standard OCI container images.
Nothing prevents you from running a bootc container.
Just beware that the results might not be what you expect, because a container CANNOT run the kernel, system services, and other componentes from a bootc container image.
Containers would run only the userspace components of a bootc container image, as they would for a regular application container.

== Workflow for building, installing, and updating image mode systems

The workflow for provisioning and maintaining edge devices using image mode starts with common tools from the application containers world, and ends up with specialized tools from the bootc world.

image::s1-devices-fig-5.svg[title="Workflow for installing and updating image mode systems"]

In summary, the process is:

. Create a containerfile, which refers to a base bootc container image, and which aggregages RHEL and third-party packages, configuration files, and optionally application container images in a single bootc container image.

. Use Podman (or any other tool capable of producing OCI containers) to build the bootc container image from your containerfile.

. Upload (push) your bootc container image to an OCI container registry, where it can be downloaded (pull) to perform installation and updates of image mode systems.

. Use the standard RHEL installer (Anaconda) with a custom kickstart file, which refers to the bootc container image as its installation source.

. Alternatively, use *bootc image builder* utility to convert your bootc container image into a custom RHEL installation media, which you can write to an USB media, or copy to a network boot server, and use it to install image mode systems without requiring access to an OCI container registry.

. Use the bootc utility, from an image mode system, to download a new bootc container image and make it the new system image.

. Alternatively, use the bootc utility, from an image mode system, to copy a new bootc container image from removable storage and make it the new system image.

This course, which is the first in a series of three, focus on steps 1-4 above. 
These are steps a developer would perform to create and test a bootc container image.

image::s1-devices-fig-6.svg[title="Scope of this course"]

The remaining steps are detailed in follow-up courses, and corresponds to stops an IT or OT professional would perform on edge systems.

// This is very long, can we postpone some of it to later sections?

== What's Next

Before learning about crafting containerfiles for bootc container images, you will assess your understanding of how edge sites differ from traditional corporate IT data centers and cloud IT.

The first activity verifies that you have all necessary prerequisites to build and deploy bootc container images in a disconnected environment.
It should provide enough information for you to replicate the activities in your own environment, if you prefer, or try a simpler deployment, not air-gaped.
