<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Test Bootc Containers With Anaconda :: Building System Images for Red Hat Device Edge With Image Mode for RHEL</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="s2-install-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-bootc-build/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-bootc-build" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Red Hat Device Edge and Image Mode for RHEL.</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s1-rhde-and-image-mode.html">Provision and Manage Edge Devices with RHEL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s2-edge-devices-quiz.html">Quiz: Use Cases for Edge Devices and Red Hat Device Edge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s3-prereqs-lab.html">Lab: Prepare to Build and Deploy Bootc Container Images</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-build/index.html">Build Bootc Containers for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s1-podman.html">Build Bootc Containers With Podman</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s2-podman-lab.html">Lab: Build and Test Bootc Containers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s3-containerfiles.html">Strategies for Building Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s4-containerfiles-lab.html">Lab: System Configuration From Containers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Test Bootc Containers for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s1-bootc-anaconda.html">Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s3-troubleshoot-lab.html">Lab: Troubleshoot Bootc Containers and Their Containerfiles</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch4-publish/index.html">Publish Bootc Containers for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch4-publish/s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch4-publish/s2-bootc-install-lab.html">Lab: Publish a Bootc Container Image in a Private Container Registry</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building System Images for Red Hat Device Edge With Image Mode for RHEL</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a></li>
    <li><a href="index.html">Test Bootc Containers for Edge Devices</a></li>
    <li><a href="s1-bootc-anaconda.html">Test Bootc Containers With Anaconda</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Test Bootc Containers With Anaconda</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>11 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Introduce the bootc utility and how the RHEL installer (Anaconda) can use a bootc container image as its installation source.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not Started
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_provisory_outline"><a class="anchor" href="#_provisory_outline"></a>PROVISORY OUTLINE</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Bootc is inside bootc containers and involved at deployment, updates, and other moments</p>
</li>
<li>
<p>Using bootc install to a disk or filesystem</p>
</li>
<li>
<p>Introduction to libvirt and macadm</p>
</li>
<li>
<p>Mention Podman Machine/Podman Desktop tools for Windows and Mac developers</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_install_image_mode_systems"><a class="anchor" href="#_how_to_install_image_mode_systems"></a>How to install image mode systems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Previous chapters demonstrate the need to perform system testing of bootc container images.
You just cannot validate that all system settings in a bootc container image are applied and work as intended using a container engine such as Podman.</p>
</div>
<div class="paragraph">
<p>To perform system testing, you must install an image mode system, and them boot the system.
There are multiple ways of installing an image mode system, among them:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the standard RHEL installation media and provide a custom kickstart configuration that references a bootc container image as its installation source.</p>
</li>
<li>
<p>Start from a system already running RHEL and run the Bootc utility, from a bootc container image, to install the system, effectivelly overwriting its current RHEL installation with a booc container image.</p>
</li>
<li>
<p>Use the Bootc Image Builder tool to build either a custom installation or a custom cloud image which embeds a pre-installed bootc container image.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this chapter, we use option (1) above, and in the next chapter, we use option (2), as two ways of performing quick testing of a bootc container image.
A follow-up course will teach option (3) as the recommended way of deploying edge systems in production.</p>
</div>
<div class="paragraph">
<p>Before we teach the specifics of how to craft and run a kickstart file that uses a bootc container image, let&#8217;s consider how much configurations, or how little, should actually be in a bootc container or left to be performed after installing an image mode systems.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_day_0_and_day_1_system_configuration"><a class="anchor" href="#_day_0_and_day_1_system_configuration"></a>Day-0 and Day-1 System Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bootc container images open the possibily for including, in a system image, many configuration settings that would typically be performed at day-2 in a package mode system or, as some would say, at day-1, right after performing installation.</p>
</div>
<div class="paragraph">
<p>This means not only a faster time to install an image mode system, compared to a package mode system, but also a faster time to configure it and be ready to onboard its users.</p>
</div>
<div class="paragraph">
<p>Some organizations perform such day-1 configurations using system installation scripting tools, for example Anaconda kickstart and Cloud-init.
Others perform such configuration using automation technologies, such as Red Hat Ansible Automation Platform.</p>
</div>
<div class="paragraph">
<p>The need for performing day-1 configurations does NOT disappear with image mode systems.
Sure, you may include a large set of configurationsin a system image, but there are usually something which must be different between devices or between edge sites.</p>
</div>
<div class="paragraph">
<p>Managing a large number of images, to account for those variations, may become a challenge.
It may be easier to produce a golden system image, which is shared by a large number of edge devices and sites, and perform minimal day-1 configuration after (or during) installation.</p>
</div>
<div class="sect2">
<h3 id="_secrets_management_and_device_onboarding"><a class="anchor" href="#_secrets_management_and_device_onboarding"></a>Secrets management and device onboarding</h3>
<div class="paragraph">
<p>Another concern with including system and application configurations in a system images come from potential risk scenarios related to secrets management, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A a removable media, used to provision edge devices, was stolen or lost, and it includes credentials to access line-of-business (LOB) databases or to perform payments.</p>
</li>
<li>
<p>A rogue device is plugged into network of an edge site, installed as a genuine device, and them taken off-site to access its system disk and grab the credentials stored there.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notice that having such credentials, or secrets, outside of a system image, but inside custom installation media, such as within a kickstart script, present similar risks.</p>
</div>
<div class="paragraph">
<p>To manage such risks, many organizations employ secure and auditable <em>onboarding</em> processes, which completes the day-1 configuration of edge devices by adding device and site specific IDs and installing secrets for acessing applications and other resources in either the edge site or around the corporate network.</p>
</div>
<div class="paragraph">
<p>You can implement effective onboarding processes with traditional automation tools, and maybe you already have mature processes which you use on branch offices and other "larger" near edge sites, and it is OK attempting to scale them to far edge scenarios.</p>
</div>
<div class="paragraph">
<p>Alternatively there are alternatives technologies and tools, designed to address the challenges of provisioning and onboarding edge devices at scale and in a secure way. Among them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The FIDO Device Onboarding (FDO) standard</p>
</li>
<li>
<p>The Red Hat Edge Manager product, based on the Flightctl open source project</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These technologies also consider the challenges of dealing with with hundreds or thousands of edge devices, as opposed to dozen or servers, and dealing with lower network bandwith or higher latency than in typical data centers and office buildings.</p>
</div>
</div>
<div class="sect2">
<h3 id="_secrets_in_bootc_container_images"><a class="anchor" href="#_secrets_in_bootc_container_images"></a>Secrets in bootc container images</h3>
<div class="paragraph">
<p>In summary, the general advice is to avoid having secrets embedded in a bootc container image, and use instead some day-1 configuration approach to add them.
Consider that user passwords, for log in in a system console, and SSH keys, for remote access to a system, are also secrets.</p>
</div>
<div class="paragraph">
<p>Some secrets are designed to be public and could be safely embedded into a system image, for example a CA certificate to access corporate servers without disabling TLS validation.</p>
</div>
<div class="paragraph">
<p>Some other secrets may require careful assessments of the risks, for example credentials to download container images from a private registry:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If such images contain corporate intelectual property, you may handle these credentials as sensitive secrets.</p>
</li>
<li>
<p>If such images are just mirrors of publicly available images, you may embed these credentials on your system images.</p>
</li>
<li>
<p>If your registry contains a mix of public and privage images, you may need different credentials for each set of images, and audit access permissions granted to each of them.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In this course, we will provide secrets using kickstart files, for simplicity.
Be aware it may not be a secure alternative for your real-world scenarios.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also consider the different secrets you may require at bootc image build time, versus the secrets you require at runtime, on actual edge devices, and during system or integration testing.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anaconda_and_bootc"><a class="anchor" href="#_anaconda_and_bootc"></a>Anaconda and bootc</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The standard RHEL installer program, called Anaconda, is capable of installing both package mode and image mode systems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the first case, the installation source is a DNF repository which provides RHEL packages.</p>
</li>
<li>
<p>In the second case, the insallation source is a bootc container image.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When Anaconda uses a bootc container image, it runs bootc to install the kernel, bootloader, and other settings from the container image.
Before running bootc, Anaconda performs any required preparation, for example partitioning disks and initializing network, and also performs any day-1 configuration selected by the user, such as setting a root password.</p>
</div>
<div class="paragraph">
<p>Current releases of Anaconda default to package mode systems, using DNF repositories from either Red Hat, over the Internet, or from the RHEL installation media itself.
The difference between the two RHEL installation medias, the smaller "standard" one (which used to be called the <em>netinstall</em> media) and the larger one, which allows off-line installation, is just the presense of such repository on the media itself.</p>
</div>
<div class="paragraph">
<p>Both RHEL installation medias contain a complete RHEL system, which boots and autoruns Anaconda, which in turn starts a set of interactive screens for configuring package selection, destination disk, partitioning, network configuration, and initial users.</p>
</div>
<div class="paragraph">
<p>Kickstart scripts automate those screens, enabling fully automated and even headless installation of RHEL, and also provide access to Anaconda features which may not be available on its interactive screens.</p>
</div>
<div class="paragraph">
<p>Unfortunatelly, <strong>you CANNOT use the interactive mode of Anaconda to select a bootc container image as its installation source</strong>.
You MUST provide a kickstart script to install an image mode system.
It does not need to be a complete kickstart script for unattended installation, but it probably will be, for edge devices.
So you can provide a kickstart file which selects a bootc container image and still use interactive screens to partition disks and set a root password.</p>
</div>
<div class="paragraph">
<p>Kickstart scripts can also embed custom scripts which they run before starting installation (in a <code>%pre</code> block) and after completing the insallation, but before rebooting the system (in a <code>%post</code> block).
These capabilities will be handly to perform system testing of bootc container images without requiring custom installation media nor an OCI container registry server.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_local_vms_on_rhel"><a class="anchor" href="#_local_vms_on_rhel"></a>Local VMs on RHEL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The native local hypervidor on RHEL systems is a stack composed of three parts:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">KVM</dt>
<dd>
<p>A kernel module which provides hardware-assisted virtualization of CPUs, memory, and system busses.</p>
</dd>
<dt class="hdlist1">QEMU</dt>
<dd>
<p>A software emulator which provides all other virtual hardware required to create an actual VM, for example video, disk, and network devices.
QEMU is also capable of emulating a complete system, for example to emulare an ARM CPU on an Intel system.</p>
</dd>
<dt class="hdlist1">Libvirt</dt>
<dd>
<p>A management layer which orchestrates KVM, QEMU, and other Linux kernel features to ease creation and management of local VMs.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A number of tools from RHEL, for example the Cockpit web management interface, and the <code>virt-install</code> command, use libvirt to mange local VMs based on KVM and QEMU.</p>
</div>
<div class="paragraph">
<p>You do NOT requite a RHEL system, nor a Linux system with libvirt, to perform system testing of bootc container images.
You can use the native hypervisor of your Windows or MacOS laptop, but this course does not provide instructions for doing it.</p>
</div>
<div class="sect2">
<h3 id="_libvirt_developer_features"><a class="anchor" href="#_libvirt_developer_features"></a>Libvirt developer features</h3>
<div class="paragraph">
<p>Libvirt is the single host management layer at the foundation of many of enterprise virtualization tools, such as OpenShift Virtualization and Red Hat OpenStack.
It provides many advanced capabilities at its API level, which require dealing with XML configuration files.</p>
</div>
<div class="paragraph">
<p>For system testing of bootc container images, we are more interested on libvirt features designed to support a developer inner loop, such as:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Session interface</dt>
<dd>
<p>Enables managing local VMs in <em>rootless</em> mode.
Yes, you can run VMs in Linux without <code>sudo</code>.</p>
</dd>
<dt class="hdlist1">User mode networking</dt>
<dd>
<p>Avoids the need for privileged access to configure host networking, such as virtual NICs and bridge devices.
It is the same technology which enables network connections to rootless containers with Podman.</p>
</dd>
<dt class="hdlist1">Direct kernel loading</dt>
<dd>
<p>Bypass the boot loader in a disk image or device, and loads a Linux kernel and initial ram disk directly from a local or remote directory.</p>
</dd>
<dt class="hdlist1">Virtio devices backed by host directories</dt>
<dd>
<p>Enables sharing files with a VM without creation of disk images, and without requiring privileged access for managing loopback devices.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These features are commonly used by developers and platform engineers, running desktop Linux distributions such as Fedora, to manage RHEL VMs for testing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unnatended_vm_creation_with_the_virt_install_comand"><a class="anchor" href="#_unnatended_vm_creation_with_the_virt_install_comand"></a>Unnatended VM creation with the virt-install comand</h3>
<div class="paragraph">
<p>Typically, a RHEL administrator would provide kickstart scripts in an HTTP server, and use the interactive features of Grub to provide kernel arguments that reference that kickstart file.
A similar process is normally used to provision RHEL systems using network boot, either PXE or UEFI.</p>
</div>
<div class="paragraph">
<p>It is also somewhat common that RHEL administrators use the <code>xorriso</code> tool suite, such as the <code>mkksiso</code> command, to produce a custom RHEL installation media which already embeds a custom kickstart script and third-party package repositories, so they do NOT need to enter Grub&#8217;s interactive screens.</p>
</div>
<div class="paragraph">
<p>But, using the features mentioned in the previous session, we can perform a quicker workflow, which uses a kickstart script in a local directory, and a bootc container image also in a local directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A virtio device provides the kickstart script and bootc container image.</p>
</li>
<li>
<p>Direct kernel loading provides kernel commands that make Anaconda use the kickstart script.</p>
</li>
<li>
<p>The session interface and user mode networking elliminate the need for privileged access (<code>sudo</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also give the kernel more options which enable a serial, text console, so you do not need a graphical desktop to create a VM and follow its boot screens.
This way, you can create test VMs over an SSH connection or as part of a CI/CD pipeline and save its boot messages in a text file for troubleshooting.</p>
</div>
<div class="paragraph">
<p>These options are not yet available from graphical front-ends to libvirt, but they are available from the <code>virt-install</code> command, which we use in the next activity.</p>
</div>
<div class="paragraph">
<p>After you create your test VM, you can manage it using any libvirt front-end, for example the <code>virsh</code> command or Cockpit.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s Next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next activity uses the standard RHEL installation media to create a libvirt VM which boots from the contents of a bootc container image.
This is one way you can perform comprehensive tests of bootc container images, before you publish it for use in production systems.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Test Bootc Containers for Edge Devices</a></span>
  <span class="next"><a href="s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
