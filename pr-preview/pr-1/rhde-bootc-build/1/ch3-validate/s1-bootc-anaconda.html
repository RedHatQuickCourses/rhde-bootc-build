<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Test Bootc Container Images with Anaconda :: Building System Images for Red Hat Device Edge with Image Mode for RHEL</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="s2-install-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-bootc-build/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-bootc-build" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Red Hat Device Edge and Image Mode for RHEL.</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s1-rhde-and-image-mode.html">Provision and Manage Edge Devices with RHEL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s2-edge-devices-quiz.html">Quiz: Use Cases for Edge Devices and Red Hat Device Edge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s3-prereqs-lab.html">Lab: Prepare to Build and Deploy Bootc Container Images</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-build/index.html">Build Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s1-podman.html">Build Bootc Containers With Podman</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s2-podman-lab.html">Lab: Build and Test Bootc Containers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s3-containerfiles.html">Strategies for Building Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s4-containerfiles-lab.html">Lab: System Configuration From Containers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Test Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s1-bootc-anaconda.html">Test Bootc Container Images with Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s3-troubleshoot-lab.html">Lab: Troubleshoot Bootc Containers and Their Containerfiles</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch4-publish/index.html">Publish Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch4-publish/s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch4-publish/s2-bootc-install-lab.html">Lab: Publish a Bootc Container in a Private Container Registry</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building System Images for Red Hat Device Edge with Image Mode for RHEL</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a></li>
    <li><a href="index.html">Test Bootc Container Images for Edge Devices</a></li>
    <li><a href="s1-bootc-anaconda.html">Test Bootc Container Images with Anaconda</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Test Bootc Container Images with Anaconda</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>11 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Introduce the bootc utility and how the RHEL installer (Anaconda) can use a bootc container image as its installation source.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Pending review
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_install_image_mode_systems"><a class="anchor" href="#_how_to_install_image_mode_systems"></a>How to install image mode systems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Previous chapters demonstrate the need to perform system testing of bootc container images.
You just cannot validate that all system settings in a bootc container image are applied and work as intended using a container engine such as Podman.</p>
</div>
<div class="paragraph">
<p>To perform system testing, you must install an image mode system, and them boot the system.
There are multiple ways of installing an image mode system, among them:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the standard RHEL installation media and provide a custom kickstart configuration that references a bootc container image as its installation source.</p>
</li>
<li>
<p>Start from a system already running RHEL and run the bootc utility, from a bootc container image, to install the system, effectively overwriting its current RHEL installation with a bootc container image.</p>
</li>
<li>
<p>Use the bootc image builder tool to create either a custom installation media or a custom cloud image which embeds a bootc container image.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this chapter, we use option (1) above, and in the next chapter, we use option (2), to demonstrate two approaches for performing quick system testing of a bootc container image.
A follow-up course will teach option (3) as the recommended way of deploying edge systems in production.</p>
</div>
<div class="paragraph">
<p>Before we teach the specifics of how to craft and run a kickstart file that uses a bootc container image, we have tp consider how much configurations, or how little, should actually be in a bootc container or left to be performed after installing an image mode systems.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_day_0_and_day_1_system_configuration"><a class="anchor" href="#_day_0_and_day_1_system_configuration"></a>Day-0 and day-1 system configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bootc container images open the possibility for including, in a system image, many configuration settings that would typically be performed at day-2 in a package mode system or, as some would say, at day-1, right after performing installation.</p>
</div>
<div class="paragraph">
<p>This means not only a faster time to install an image mode system, compared to a package mode system, but also a faster time to configure it and be ready to its intended uses.</p>
</div>
<div class="paragraph">
<p>Some organizations perform such day-1 configurations using system installation scripting tools, for example Anaconda kickstart and Cloud-init.
Others perform such configuration using automation technologies, such as Red Hat Ansible Automation Platform.</p>
</div>
<div class="paragraph">
<p>The need for performing day-1 configurations does NOT disappear with image mode systems.
Sure, you may include a large set of configurations in a system image, but in most cases there is something which must be different between individual devices or between different edge sites.</p>
</div>
<div class="paragraph">
<p>Managing a large number of images, to account for those variations, may become a challenge.
It may be easier to produce a golden system image, which is shared by a large number of edge devices and sites, and perform minimal day-1 configuration after (or during) installation.</p>
</div>
<div class="sect2">
<h3 id="_secrets_management_and_device_on_boarding"><a class="anchor" href="#_secrets_management_and_device_on_boarding"></a>Secrets management and device on-boarding</h3>
<div class="paragraph">
<p>Another concern with including system and application configurations in a system images come from potential risk scenarios related to secrets management, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A a removable media, used to provision edge devices, was stolen or lost, and it includes credentials to access line-of-business (LOB) databases or to perform payments.</p>
</li>
<li>
<p>A rogue device is plugged into network of an edge site, automatically discovered and installed as if it were a genuine device, and then taken off-site to access its system disk and grab the credentials stored there.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notice that having such credentials, or secrets, outside of a system image, but inside custom installation media, such as within a kickstart script, present similar risks.</p>
</div>
<div class="paragraph">
<p>To manage such risks, many organizations employ secure and auditable <em>on-boarding</em> processes, which completes the day-1 configuration of edge devices by adding device and site specific IDs and installing secrets for accessing applications and other resources in either the edge site or around the corporate network.</p>
</div>
<div class="paragraph">
<p>Such on-boarding processes must rely on an initial set of credentials, but those credentials must be short lived, and deleted from the device right at the beginning of the process.
Anyway, the initial credentials provide access to the device itself but not to anything outside of the device.</p>
</div>
<div class="paragraph">
<p>If you put such credentials in your bootc container image, you would NOT be able to remove them, and it becomes a security vulnerability.
As stated by the <a href="https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/">OWASP Top 10 2021</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Do not ship or deploy with any default credentials, particularly for admin users.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You can implement effective on-boarding processes with traditional automation tools, and maybe you already have mature processes which you use on branch offices and other "larger" near edge sites, and it is OK attempting to scale them to far edge scenarios.</p>
</div>
<div class="paragraph">
<p>There are alternatives technologies and tools, designed to address the challenges of provisioning and on-boarding edge devices at scale and in a secure way. Among them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://fidoalliance.org/device-onboarding-overview/" target="_blank" rel="noopener">FIDO Device Onboarding</a> (FDO) standard.</p>
</li>
<li>
<p>The <a href="https://www.redhat.com/en/about/press-releases/red-hat-introduces-red-hat-edge-manager-overseeing-fleets-devices" target="_blank" rel="noopener">Red Hat Edge Manager product</a>, based on the <a href="https://github.com/flightctl/flightctl" target="_blank" rel="noopener">flightctl</a> open source project.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These technologies also consider the challenges of dealing with with hundreds or thousands of edge devices, as opposed to dozen or hundreds of servers, and dealing with lower network bandwidth or higher latency than in typical data centers and office buildings.</p>
</div>
</div>
<div class="sect2">
<h3 id="_secrets_in_bootc_container_images"><a class="anchor" href="#_secrets_in_bootc_container_images"></a>Secrets in bootc container images</h3>
<div class="paragraph">
<p>In summary, the general advice is to avoid having secrets embedded in a bootc container image, and use instead some day-1 configuration approach to add them.
Consider that user passwords, for log in in a system console, and SSH keys, for remote access to a system, are also secrets.</p>
</div>
<div class="paragraph">
<p>Some secrets are designed to be public and could be safely embedded into a system image, for example a CA certificate to access corporate servers without disabling TLS validation.</p>
</div>
<div class="paragraph">
<p>Some other secrets may require careful assessments of the risks, for example credentials to download container images from a private registry:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If such images contain corporate intellectual property, you may handle these credentials as sensitive secrets.</p>
</li>
<li>
<p>If such images are just mirrors of publicly available images, you may embed these credentials on your system images.</p>
</li>
<li>
<p>If your registry contains a mix of public and private images, you may need different credentials for each set of images, and audit access permissions granted to each of them.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In this course, we will provide secrets using kickstart files, for simplicity.
Be aware it may not be a secure alternative for your real-world scenarios.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also consider the different secrets you may require at bootc image build time, versus the secrets you require at runtime, on actual edge devices, and during system or integration testing.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anaconda_and_bootc"><a class="anchor" href="#_anaconda_and_bootc"></a>Anaconda and bootc</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The standard RHEL installer program, called Anaconda, is capable of installing both package mode and image mode systems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the first case, the installation source is a DNF or YUM repository which provides RHEL packages.</p>
</li>
<li>
<p>In the second case, the installation source is a bootc container image.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When Anaconda uses a bootc container image, it runs bootc to install the kernel, boot loader, and other settings from the container image.
Before running bootc, Anaconda performs any required preparation, for example partitioning disks and initializing network, and also performs any day-1 configuration selected by the user, such as setting a root password.</p>
</div>
<div class="paragraph">
<p>Current releases of Anaconda default to package mode systems, using DNF repositories from either Red Hat, over the Internet, or from the RHEL installation media itself.
The difference between the two RHEL installation medias, the smaller "standard" one (which used to be called the <em>netinstall</em> media) and the larger one (the <em>DVD</em> media), which allows off-line installation, is just the presence of such repositories on the media itself.</p>
</div>
<div class="paragraph">
<p>Both RHEL installation medias contain a minimal, bootable RHEL system, which runs Anaconda to provide a set of interactive screens for configuring package selection, destination disk, partitioning, network configuration, and initial users.</p>
</div>
<div class="paragraph">
<p>Kickstart scripts automate those screens, enabling fully automated and even headless installation of RHEL, and also provide access to Anaconda features which may not be available on its interactive screens.</p>
</div>
<div class="paragraph">
<p>Unfortunately, <strong>you CANNOT yet use the interactive mode of Anaconda to select a bootc container image as its installation source</strong>.
You MUST provide a kickstart script to install an image mode system.
It does not need to be a complete kickstart script for unattended installation, but it probably will be, for edge devices.
You could provide a minimal kickstart file which just selects a bootc container image and use interactive screens to partition disks and set a root password.</p>
</div>
<div class="paragraph">
<p>Kickstart scripts can also embed custom scripts which they run before starting installation (in a <code>%pre</code> block) and after completing the installation, but before rebooting the system (in a <code>%post</code> block).
These capabilities will be handy to perform system testing of bootc container images without requiring custom installation media nor an OCI container registry server.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_local_vms_on_rhel"><a class="anchor" href="#_local_vms_on_rhel"></a>Local VMs on RHEL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The native local hypervisor on RHEL systems is a stack composed of three parts:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">KVM</dt>
<dd>
<p>A kernel module which provides hardware-assisted virtualization of CPUs, memory, and system busses.</p>
</dd>
<dt class="hdlist1">QEMU</dt>
<dd>
<p>A software emulator which provides all other virtual hardware required to create an actual VM, for example video, disk, and network devices.
QEMU is also capable of emulating a complete system, for example to emulate an ARM CPU on an Intel system.</p>
</dd>
<dt class="hdlist1">Libvirt</dt>
<dd>
<p>A management layer which orchestrates KVM, QEMU, and other Linux kernel features to ease creation and management of local VMs.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A number of tools from RHEL, for example the Cockpit web management interface, and the <code>virt-install</code> command, use libvirt to mange local VMs based on KVM and QEMU.</p>
</div>
<div class="paragraph">
<p>You do NOT requite a RHEL system, nor a Linux system with libvirt, to perform system testing of bootc container images.
You can use the native hypervisor of your Windows or MacOS laptop, but this course does not provide instructions for doing it.</p>
</div>
<div class="sect2">
<h3 id="_libvirt_features_for_developers"><a class="anchor" href="#_libvirt_features_for_developers"></a>Libvirt features for developers</h3>
<div class="paragraph">
<p>Libvirt is the single host management layer at the foundation of many of enterprise virtualization tools, such as OpenShift Virtualization and Red Hat OpenStack.
It provides many advanced capabilities at its API level, which require dealing with XML configuration files.</p>
</div>
<div class="paragraph">
<p>For system testing of bootc container images, we are more interested on libvirt features designed to support a developer&#8217;s inner loop, such as:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Session interface</dt>
<dd>
<p>Enables managing local VMs in <em>rootless</em> mode.
Yes, you can run VMs in Linux without <code>sudo</code>.</p>
</dd>
<dt class="hdlist1">User mode networking</dt>
<dd>
<p>Avoids the need for elevated privileges to configure host networking, such as virtual NICs and bridge devices.
It is the same technology which enables network connections to rootless containers with Podman.</p>
</dd>
<dt class="hdlist1">Direct kernel loading</dt>
<dd>
<p>Bypass the boot loader in a disk image or device, and loads a Linux kernel and initial ram disk directly from a local or remote directory, or from installation media.</p>
</dd>
<dt class="hdlist1">Virtio devices backed by host directories</dt>
<dd>
<p>Enables sharing files with a VM without creation of disk images, and without requiring elevated privileges for managing loopback devices.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These features are commonly used by developers and platform engineers, running desktop Linux distributions such as Fedora, to manage RHEL VMs for testing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unattended_vm_creation_with_the_virt_install_comand"><a class="anchor" href="#_unattended_vm_creation_with_the_virt_install_comand"></a>Unattended VM creation with the virt-install comand</h3>
<div class="paragraph">
<p>Typically, a RHEL administrator would provide kickstart scripts in an HTTP server, and use the interactive features of Grub to provide kernel arguments that reference that kickstart file.
A similar process is normally used to provision RHEL systems using network boot, either PXE or UEFI.</p>
</div>
<div class="paragraph">
<p>It is also somewhat common that RHEL administrators use the <code>xorriso</code> tool suite, especially the <code>mkksiso</code> command, to produce a custom RHEL installation media which already embeds a custom kickstart script and third-party package repositories, so they do not need to enter Grub&#8217;s interactive screens.</p>
</div>
<div class="paragraph">
<p>But, using the features mentioned in the previous session, we can implement a simpler workflow, which uses a kickstart script in a local directory, and a bootc container image also in a local directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A virtio device provides the kickstart script and bootc container image.</p>
</li>
<li>
<p>Direct kernel loading provides kernel commands that make Anaconda use the kickstart script.</p>
</li>
<li>
<p>The session interface and user mode networking eliminate the need for privileged access (<code>sudo</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also give the kernel additional options which enable a serial, text console, so you do not need a graphical desktop to create a VM and follow its boot screens.
This way, you can create test VMs over an SSH connection or as part of a CI/CD pipeline and save its boot messages in a text file for troubleshooting, if something goes wrong.</p>
</div>
<div class="paragraph">
<p>These options are not yet available from graphical front-ends to libvirt, but they are available from the <code>virt-install</code> command, which we use in the next activity.</p>
</div>
<div class="paragraph">
<p>After you create your test VM, you can manage it using any libvirt front-end, for example the <code>virsh</code> command or Cockpit.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_system_testing_with_podman_desktop"><a class="anchor" href="#_system_testing_with_podman_desktop"></a>System testing with Podman Desktop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Recent releases of Podman Desktop include the ability of creating test VMs from bootc container images.
But wait, Podman Desktop is a tool to manage containers, not VMs!</p>
</div>
<div class="paragraph">
<p>In fact, developers using Podman, or any other container engine on Windows and MacOS, are running a Linux VM.
When most people refer to "containers", they are actually referring to "Linux containers" which require running on a Linux system, interacting with a Linux kernel and other Linux operating system services.</p>
</div>
<div class="paragraph">
<p>So most container engines already provide a thin VM management layer, which is single-purpose: to manage the Linux VM they need to run Linux containers.
That thin VM management layer usually interfaces with the native hypervisor on Windows, MacOS, and Linux systems, so that developers are insulated from VM management and only care about containers.</p>
</div>
<div class="paragraph">
<p>The Podman Machine project, which provides the VM management layer of Podman and Podman Desktop, also enables creating VMs from a bootc container image.
Thanks to that capability, recent releases of Podman Desktop provide a bootc extension which offer a simple and portable abstraction for developers who need to perform system testing of their bootc container images.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
in this course, we are not using Podman Desktop because of challenges with providing remote graphical desktops to the classroom environment, but we encourage learners to explore this alternative.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next activity uses the standard RHEL installation media to create a libvirt VM which boots from the contents of a bootc container image.
This is one way you can perform comprehensive tests of bootc container images, before you publish it for use in production systems.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Test Bootc Container Images for Edge Devices</a></span>
  <span class="next"><a href="s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
