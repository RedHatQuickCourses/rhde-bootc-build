<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Strategies for Publishing and Distributing Bootc Container Images :: Building System Images for Red Hat Device Edge With Image Mode for RHEL</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="s2-bootc-install-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-bootc-build/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-bootc-build" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Red Hat Device Edge and Image Mode for RHEL.</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s1-rhde-and-image-mode.html">Provision and Manage Edge Devices with RHEL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s2-edge-devices-quiz.html">Quiz: Use Cases for Edge Devices and Red Hat Device Edge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s3-prereqs-lab.html">Lab: Prepare to Build and Deploy Bootc Container Images</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-build/index.html">Build Bootc Containers for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s1-podman.html">Build Bootc Containers With Podman</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s2-podman-lab.html">Lab: Build and Test Bootc Containers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s3-containerfiles.html">Strategies for Building Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s4-containerfiles-lab.html">Lab: System Configuration From Containers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch3-validate/index.html">Test Bootc Containers for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s1-bootc-anaconda.html">Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s3-troubleshoot-lab.html">Lab: Troubleshoot Bootc Containers and Their Containerfiles</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Publish Bootc Containers for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-bootc-install-lab.html">Lab: Publish a Bootc Container Image in a Private Container Registry</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building System Images for Red Hat Device Edge With Image Mode for RHEL</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building System Images for Red Hat Device Edge With Image Mode for RHEL</a></li>
    <li><a href="index.html">Publish Bootc Containers for Edge Devices</a></li>
    <li><a href="s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Strategies for Publishing and Distributing Bootc Container Images</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>9 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Introduce the direct usage of the bootc utility to test bootc container images and strategies for tagging bootc container images for test and production environments.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Work in progress
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you have your bootc container images not just built but tested in a virtual system, it is time to upload (push) it to an OCI container registry, where it can be downloaded (pulled) by edge devices during installation and upgrades.</p>
</div>
<div class="paragraph">
<p>Or maybe these images are submitted to the next step of an automated CI/CD process, where they are subject to more extensive system testing, performance testing, and vulnerability tests.
Either way, your bootc container images were not created just to sit on your development machine.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installing_bootc_container_images_using_the_bootc_utility"><a class="anchor" href="#_installing_bootc_container_images_using_the_bootc_utility"></a>Installing bootc container images using the bootc utility</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The bootc utility is the primary tool responsible for installing and upgrading image mode systems.
You can also use the bootc utility to convert a system from package mode to image mode, and some developers find this a nice approach for system testing and some kinds of integration testing.</p>
</div>
<div class="paragraph">
<p>Developers like to use cloud instances, which can be quickly provisioned, as RHEL package mode systems, from cloud images that are readily available from their cloud providers, and convert them to image mode systems.
This is another way of performing system testing new bootc container images.
This way, they skip the potentially time-consuming steps of creating a custom cloud image and uploading it to the cloud provider.</p>
</div>
<div class="paragraph">
<p>When you use bootc to install a bootc container image on a package mode system, it does NOT attempt to preserve any of the configurations and data of the original system.
The system ends up with a default system configuration and with default or empty application data directories, as they exist on the bootc container image.</p>
</div>
<div class="paragraph">
<p>So it is NOT actually a "conversion" from package mode to image mode, but a new installation using image mode, overwriting the existing package mode installation with a brand new image mode installation.</p>
</div>
<div class="paragraph">
<p>An interesting thing about the booc utility, when used for installing image mode systems, is that it is supposed to be run from the actual bootc container image being installed, as a privileged container, with access to the root file system, devices directory, and other capabilities which application containers are not usualy granted.</p>
</div>
<div class="paragraph">
<p>So you do NOT need to install booc on a package mode system to be reinstalled as an image mode system.
You just run the bootc container image with a specialy crafted command that invokes bootc with all required options.</p>
</div>
<div class="paragraph">
<p>The only real utility of the bootc utility, in a package mode system, is reporting that the system was NOT installed as an image mode system.</p>
</div>
<div class="sect2">
<h3 id="_day_1_configuration_using_the_bootc_utility"><a class="anchor" href="#_day_1_configuration_using_the_bootc_utility"></a>Day-1 configuration using the bootc utility</h3>
<div class="paragraph">
<p>The bootc utility was  not designed to be the main installation tool of an image mode system, but to be invoked by installation tools such as Anaconda.
So bootc does not provide for day-1 customizations, such as network configuration and user passwords.</p>
</div>
<div class="paragraph">
<p>This means any package mode system that is reinstalled as an image mode system by bootc may become completely locked down, with no network configurations and no user passwords nor SSH keys to access it.</p>
</div>
<div class="paragraph">
<p>Nothing prevents you from building a bootc container image with predefined network settings, such as a static IP address and hostname, or with a user with a known password.
You may want to do that for a quick test, but it is NOT how you are recommended to do for production systems.</p>
</div>
<div class="paragraph">
<p>The only day-1 configuration which can be provided by the bootc utility itself is setting up SSH keys for the root user.
If you build your bootc container image on the assumption that it takes dynamic network settings from a DHCP server or from cloud-init, the reinstalled cloud instance becomes accessible though the root SSH key.
Else, you have to provide network settings as kernel arguments, during installation time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_updating_and_switching_bootc_container_images"><a class="anchor" href="#_updating_and_switching_bootc_container_images"></a>Updating and switching bootc container images</h3>
<div class="paragraph">
<p>In future courses we will also see other uses of the bootc utility:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To check if the current bootc container image installed in a system was updated, and if true, upgrade to the newer image.</p>
</li>
<li>
<p>To switch an image mode system to a different bootc container image, which could serve to "repurpose" an image mode system to a new role.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In both cases, the bootc utility will preserve configuration and data on the image mode system.
The only difference between upgrade and switch operations is that upgrades assume the system keeps using the same container image reference, that is, the name and tag, and from the same OCI container registry.</p>
</div>
<div class="paragraph">
<p>Switches, on the other hand, happen when you change either part of the bootc container image reference.
In both cases, you run the bootc utility directly from its image mode system, and after it downloads the new or updated container image, it runs the bootc utility from that image to install the kernel, bootloader, and perform other required tasks.</p>
</div>
<div class="paragraph">
<p>A future course will demonstrate how to apply upgrades and switches to image mode system, and the implications of those operations on system settings and application data, along with common strategies for dealing with it.</p>
</div>
<div class="paragraph">
<p>For now, it is just important that you consider that any bootc conainer images you build now may be applied to systems which already were image mode systems.
You want to somehow distinguish between different versions of the same bootc container image and especially between new versions which were already subject to extensive system and integration testing from others which were not.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_floating_and_non_floating_tags"><a class="anchor" href="#_floating_and_non_floating_tags"></a>Floating and Non-Floating Tags.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What you know as the <em>name</em> of a container image is actually the name of a <em>repository</em> of container images.
The real ID of a container image is a SHA-256 checksum of its manifest, which lists all layers on the container image and provides  metadata such as labels.</p>
</div>
<div class="paragraph">
<p>In very old container engines, just copying an image between container registries, or from a registry to the local storage of a container engine, would change its ID.
Nowadays, you can expect to be able to download and copy container images and preserve their IDs.</p>
</div>
<div class="paragraph">
<p>A single container image repository could contain hundreds of different images, and each of them is accessible by their own ID.
Each container image in a repository could be completely unrelated to others, not sharing any layers at all.
This is not common, but could be done.</p>
</div>
<div class="paragraph">
<p>Because humans do not like to deal with very long random strings (the SHA-256 checksums), images can be tagged, and then you can refer to a specific image by its name and tag pair, that is <code>name:tag</code>.</p>
</div>
<div class="paragraph">
<p>So a name and tag pair links to a specific image ID, but that link could change, like a symbolic link in a Linux file system.
If you expect that a tag links to a new image ID in the future, you call it a <em>floating</em> tag.
The <code>latest</code> tag is an example of a floating tag.</p>
</div>
<div class="paragraph">
<p>If you expect that a tag remains linked to the same image ID forever, you call it a <em>fixed</em> or <em>non-floating</em> tag.
It is common that continuous integration (CI) systems and other automatic build systems assign a fixed tag, based on a sequential build number or on a timestamp, to all container images they produce.</p>
</div>
<div class="sect2">
<h3 id="_floating_and_fixed_tags_in_a_ci_pipeline"><a class="anchor" href="#_floating_and_fixed_tags_in_a_ci_pipeline"></a>Floating and fixed tags in a CI pipeline</h3>
<div class="paragraph">
<p>It is also common practice that a set of floating tags map to the latest version of an image, according to semantic versioning, and those tags are updated at the end of the testing and integration pipeline.</p>
</div>
<div class="paragraph">
<p>For example, conside the following sequence of events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is a floating tag named <code>v1.2</code>, and it now points to the same image that is also tagged as <code>v1.2-3245</code>.</p>
</li>
<li>
<p>You produce a new build of that container image, which is tagged as <code>v1.2-3246</code>.</p>
</li>
<li>
<p>Some test fails with the new build, which is never promoted to a released container image.</p>
</li>
<li>
<p>You produce another build of the same container image, which is tagged as <code>v1.2-3247</code>.</p>
</li>
<li>
<p>That newest build pass all tests, so it is also tagged as the new <code>v1.2</code>.
Now tags <code>v1.2</code> and <code>v1.2-3247</code> link to the same image ID.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similar tagging strategies enable having multiple container images, in different stages of testing, and copying (or mirroring) to  edge sites (or end customers) only the images which were actually released, while enabling different systems to perform different tests.</p>
</div>
<div class="paragraph">
<p>For example, a container registry named <code>internal.example.com</code> contains all container images produced by CI/CD, and test systems grab images from that registry.</p>
</div>
<div class="paragraph">
<p>Another container registry, named <code>production.example.com</code>, only contains images which pass all tests and are intended to be used in production systems.</p>
</div>
<div class="paragraph">
<p>This second registry would NOT contain all container images that exist in the first one.
Having a consistent tagging scheme enables administrators to take corrective action if copying or mirroring from one registry to the other fails for any reason.</p>
</div>
<div class="paragraph">
<p>You see, these are just generic practices for managing application container images, and they apply as well to bootc container images.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s Next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the next activity, you will publish a bootc container image for use by integration testings, which are performened using pre-existing VMs with the <code>bootc install</code> command.
After tests, you will you publish the bootc container with a floating tag, as a released image for use by production systems.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Publish Bootc Containers for Edge Devices</a></span>
  <span class="next"><a href="s2-bootc-install-lab.html">Lab: Publish a Bootc Container Image in a Private Container Registry</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
