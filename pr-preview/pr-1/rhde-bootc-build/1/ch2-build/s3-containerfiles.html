<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Strategies for Building Bootc Container Images :: Building System Images for Red Hat Device Edge with Image Mode for RHEL</title>
    <link rel="prev" href="s2-podman-lab.html">
    <link rel="next" href="s4-containerfiles-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-bootc-build/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-bootc-build" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Red Hat Device Edge and Image Mode for RHEL.</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s1-rhde-and-image-mode.html">Provision and Manage Edge Devices with RHEL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s2-edge-devices-quiz.html">Quiz: Use Cases for Edge Devices and Red Hat Device Edge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s3-prereqs-lab.html">Lab: Prepare to Build and Deploy Bootc Container Images</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Build Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s1-podman.html">Build Bootc Containers With Podman</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-podman-lab.html">Lab: Build and Test Bootc Containers</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s3-containerfiles.html">Strategies for Building Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s4-containerfiles-lab.html">Lab: System Configuration From Containers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch3-validate/index.html">Test Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s1-bootc-anaconda.html">Test Bootc Container Images with Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s3-troubleshoot-lab.html">Lab: Troubleshoot Bootc Containers and Their Containerfiles</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch4-publish/index.html">Publish Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch4-publish/s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch4-publish/s2-bootc-install-lab.html">Lab: Publish a Bootc Container in a Private Container Registry</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building System Images for Red Hat Device Edge with Image Mode for RHEL</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a></li>
    <li><a href="index.html">Build Bootc Container Images for Edge Devices</a></li>
    <li><a href="s3-containerfiles.html">Strategies for Building Bootc Container Images</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Strategies for Building Bootc Container Images</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>7 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Present common issues and recommendations for building bootc container images using containerfiles.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Pending review
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now that you know now to build a bootc container image from a containerfile, and you also know that most things you would do in a containerfile for application containers also apply to containerfiles for bootc containers, it&#8217;s time to consider what you could do in containerfiles for bootc images that you would NOT usually for application containers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_approaches_for_appliances_versus_enforcing_separation_of_concerns"><a class="anchor" href="#_approaches_for_appliances_versus_enforcing_separation_of_concerns"></a>Approaches for appliances versus enforcing separation of concerns</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Previous examples followed an appliance approach: application code, configurations, and initial data are embedded in a bootc container image.</p>
</div>
<div class="paragraph">
<p>This may be a good approach for edge devices which serve a single purpose, like a point of sale (POS) terminal.
It also simplifies day-2 configuration of image mode systems.</p>
</div>
<div class="paragraph">
<p>Some organizations prefer to enforce a strict separation of concerns, where an infrastructure team manages the lifecycle of operating systems while a different teams manage the lifecycle of applications.</p>
</div>
<div class="paragraph">
<p>A way of implementing this approach is to keep applications outside of bootc container images, in their own application container images, and optionally link those applications to bootc images using <a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/10/html/using_image_mode_for_rhel_to_build_deploy_and_manage_operating_systems/building-and-managing-logically-bound-images" target="_blank" rel="noopener">bounded containers</a>.</p>
</div>
<div class="paragraph">
<p>Whatever your approach, image mode enables reducing the effort and time to perform day-1 and day-2 configuration of an edge device.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_system_settings_on_containerfiles"><a class="anchor" href="#_system_settings_on_containerfiles"></a>System settings on containerfiles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Configuration of Linux systems happens mostly through text files stored in the <code>/etc</code> directory.
This is important for bootc containers because, when you build them, only changes to files become part of the resulting container image.
If your containerfile performs actions that make no changes to files, such as setting a kernel parameter by writing to <code>/proc</code>, those actions have no effect on your bootc container images.</p>
</div>
<div class="paragraph">
<p>Most system configuration commands from RHEL already perform their work by changing files, for example <code>dnf install</code> and <code>systemctl enable</code>, so they can be used in containerfiles without issues.</p>
</div>
<div class="paragraph">
<p>A few commands actually communicate with a system service, using an interprocess communication (IPC) channel and, if used in a containerfile, they would try to affect the host performing the build, but would have no effect in the resulting container image.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Do NOT try to enable the IPC mechanism during your containerfile building for example by mounting a UNIX socket file!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need such commands, you must find how their services actually store configuration data and find a way of affecting that configuration store directly, without using IPC and without to affect the build host system.</p>
</div>
<div class="paragraph">
<p>For example, the <code>firewall-cmd</code> command communicates with the Firewall daemon (Firewalld) to change the active kernel netfilter tables directly, and it would not work in a containerfile.
But there is the alternative <code>firewall-offline-cmd</code> command which only stores configuration changes that are retrieved by Firewalld at boot time.</p>
</div>
<div class="paragraph">
<p>Some commands affect data outside files, for example installing a Grub bootloader in the primary disk partition table.
Instead of running such commands on your containerfile, you create bootc configuration files and let the bootc utility apply those settings.</p>
</div>
<div class="paragraph">
<p>When your bootc container image is installed in an image mode system, the bootc utility takes care of altering the bootloader configuration on its root disk.
For example, the <code>/usr/lib/bootc/kargs.d</code> directory provides kernel arguments which bootc adds to the kernel command line of its system Grub menu.</p>
</div>
<div class="paragraph">
<p>You may find, in a containerfile for a bootc container image, some commands and files which you would not find in a containerfile for an application, but which are just standard Linux configuration files.</p>
</div>
<div class="paragraph">
<p>For example, files in the <code>/usr/lib/sysctl.d</code> directory configure kernel parameters, mimicking the <code>/proc</code> tree structure.</p>
</div>
<div class="paragraph">
<p>Think about your containerfiles as configuring a system so those settings remain persistent, and are in effect for the next time you boot a system.</p>
</div>
<div class="sect2">
<h3 id="_configuration_using_drop_files"><a class="anchor" href="#_configuration_using_drop_files"></a>Configuration using drop files</h3>
<div class="paragraph">
<p>Legacy UNIX services usually support a single configuration file.
You can (sometimes) set the path to this file, but you must provide a complete configuration file.</p>
</div>
<div class="paragraph">
<p>This can become problematic during version updates, where the syntax of the configuration file changes.
It also makes configuration management harder, because you must track multiple small changes, made to different sections of a single large file.</p>
</div>
<div class="paragraph">
<p>More modern Linux services usually support a search path for configuration files, and multiple files per directory.
The effective configuration of the service is the aggregate of all files in the search path.
They enable you to provide self-contained, small configuration files which set only the parameters you want, while relying on whatever defaults were provided by the system.
These small files are called <em>drop files</em>.</p>
</div>
<div class="paragraph">
<p>Not only you have fewer changes, which are easier to track in a version control system, but you can perform version updates and frequently keep using your configuration files form earlier versions unchanged.
It also enables reusing the same files among different systems, for example: some systems get drop files A, B, and C, while other systems get drop files A, C, and D.</p>
</div>
<div class="paragraph">
<p>The <code>/usr/lib/sysctl.d</code> directory is an example of a directory which contains drop files.
On the other hand, our single page web application example made changes to a legacy, monolithic configuration file <code>/etc/httpd/conf/httpd.conf</code>, but the Apache Web Server supports drop files in the <code>/etc/httpd/conf.d</code> directory, which we could have used.</p>
</div>
<div class="paragraph">
<p>Many of your issues will happen because you&#8217;re using legacy configurations, which were not updated to align with current recommendations and features of modern versions of Linux system and its network or system services.</p>
</div>
</div>
<div class="sect2">
<h3 id="_immutable_vs_configurable_system_settings"><a class="anchor" href="#_immutable_vs_configurable_system_settings"></a>Immutable vs configurable system settings</h3>
<div class="paragraph">
<p>Modern Linux services include two system directories to their configuration search path, one in <code>/etc</code>, and the other in <code>/usr/lib</code>.
Changes to either of them result in the same outcome, but remember the first is a writable directory in image mode systems, while the second is read-only.</p>
</div>
<div class="paragraph">
<p>The recommendation is that, whenever possible, containerfiles for bootc container images make changes to configuration files in <code>/usr/lib</code> so these changes are part of the image and it is easier to track which changes were made by a system administrator or by automation on day-2.</p>
</div>
<div class="paragraph">
<p>For most Linux services, settings in <code>/etc</code> override settings in <code>/usr/lib</code> so you are NOT locking the system into a fixed configuration, but you are preserving a pristine copy of your intended configurations.
If you need, just remove the local changes made in '/etc'.</p>
</div>
</div>
<div class="sect2">
<h3 id="_selinux_and_bootc"><a class="anchor" href="#_selinux_and_bootc"></a>SElinux and bootc</h3>
<div class="paragraph">
<p>Bootc takes care of most things that must run at either installation or update time, for example relabeling files for the correct SELinux context label.
Just remember to provide the required SELinux policies as part of your bootc container image.</p>
</div>
<div class="paragraph">
<p>Application containers usually do not need to set SELinux context labels on their files, because container engines run them within a single per-container context, based on dynamic MCS labeling.
But an image mode system, once installed from a bootc container image, enforces standard SELinux policies and contexts.</p>
</div>
<div class="paragraph">
<p>In any case, you should assume that your image mode systems will run with SELinux in enforcing mode and with a targeted policy, as the minimum acceptable security standard.</p>
</div>
</div>
<div class="sect2">
<h3 id="_one_time_systemd_units"><a class="anchor" href="#_one_time_systemd_units"></a>One time Systemd units</h3>
<div class="paragraph">
<p>Sometimes you need to add custom code which you intend to run only once, during installation, or at every boot.
This is a standard Systemd feature, so you just add Systemd unit files to you bootc container image, and of course also add the scripts or binaries those units reference.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_need_for_system_testing"><a class="anchor" href="#_the_need_for_system_testing"></a>The need for system testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After you build a containerfile which includes system settings, you can verify that the correct configuration files exist in your bootc container image by running it with Podman.
But you CANNOT verify that these settings are actually in effect, nor that they produce the intended outcomes.</p>
</div>
<div class="paragraph">
<p>Remember that container engines run application containers with their current host kernel and system settings.
The kernel, system services, and settings inside a bootc container image are simply ignored when run from a container engine.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next activity builds a bootc container image which varied system settings, demonstrates that these settings are stored in the image but not active in a container. The next chapter shows how to perform system testing of bootc container images by installing them in a local VM.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="s2-podman-lab.html">Lab: Build and Test Bootc Containers</a></span>
  <span class="next"><a href="s4-containerfiles-lab.html">Lab: System Configuration From Containers</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
