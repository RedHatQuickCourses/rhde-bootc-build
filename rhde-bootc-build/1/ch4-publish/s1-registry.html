<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Strategies for Publishing and Distributing Bootc Container Images :: Building System Images for Red Hat Device Edge with Image Mode for RHEL</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="s2-bootc-install-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-bootc-build/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-bootc-build" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Red Hat Device Edge and Image Mode for RHEL.</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s1-rhde-and-image-mode.html">Provision and Manage Edge Devices with RHEL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s2-edge-devices-quiz.html">Quiz: Use Cases for Edge Devices and Red Hat Device Edge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s3-prereqs-lab.html">Lab: Prepare to Build and Deploy Bootc Container Images</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-build/index.html">Build Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s1-podman.html">Build Bootc Containers With Podman</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s2-podman-lab.html">Lab: Build and Test Bootc Containers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s3-containerfiles.html">Strategies for Building Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-build/s4-containerfiles-lab.html">Lab: System Configuration From Containers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch3-validate/index.html">Test Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s1-bootc-anaconda.html">Test Bootc Container Images with Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s2-install-lab.html">Lab: Test Bootc Containers With Anaconda</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-validate/s3-troubleshoot-lab.html">Lab: Troubleshoot Bootc Containers and Their Containerfiles</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Publish Bootc Container Images for Edge Devices</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-bootc-install-lab.html">Lab: Publish a Bootc Container in a Private Container Registry</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building System Images for Red Hat Device Edge with Image Mode for RHEL</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building System Images for Red Hat Device Edge with Image Mode for RHEL</a></li>
    <li><a href="index.html">Publish Bootc Container Images for Edge Devices</a></li>
    <li><a href="s1-registry.html">Strategies for Publishing and Distributing Bootc Container Images</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Strategies for Publishing and Distributing Bootc Container Images</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>9 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Introduce the direct usage of the bootc utility to test bootc container images and strategies for tagging bootc container images for test and production environments.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Pending review
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you have your bootc container images not just built but tested in a virtual system, it is time to upload (push) it to an OCI container registry, where it can be downloaded (pulled) by edge devices during installation and upgrades.</p>
</div>
<div class="paragraph">
<p>Or maybe these images are yet to be submitted to the next step of an automated CI/CD process, where they are subject to more extensive system testing, performance testing, and vulnerability tests.
Either way, your bootc container images were not created just to sit on your development machine.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installing_bootc_container_images_using_the_bootc_utility"><a class="anchor" href="#_installing_bootc_container_images_using_the_bootc_utility"></a>Installing bootc container images using the bootc utility</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The bootc utility is the primary tool responsible for installing and upgrading image mode systems.
You can also use the bootc utility to convert a system from package mode to image mode, and some developers find this a nice approach for system testing and some kinds of integration testing.</p>
</div>
<div class="paragraph">
<p>Start from a cloud instance, which is quickly provisioned as a RHEL package mode system, using cloud images that are readily available from their cloud providers.
Then convert it to an image mode system.
This way, they skip the potentially time-consuming steps of creating a custom cloud image and uploading it to the cloud provider.</p>
</div>
<div class="paragraph">
<p>When you use bootc to install a bootc container image on a package mode system, it does NOT attempt to preserve any of the configurations and data of the original system.
The system ends up with a default system configuration and with default or empty application data directories, as they exist on the bootc container image.</p>
</div>
<div class="paragraph">
<p>So it is NOT actually a "conversion" from package mode to image mode, but a new installation using image mode, overwriting the existing package mode installation with a brand new image mode installation.</p>
</div>
<div class="paragraph">
<p>A caveat about the booc utility, when used for installing image mode systems, is that it is supposed to be run from the actual bootc container image being installed, as a privileged container.
It also requires with access to the host&#8217;s root file system, devices directory, and other capabilities which application containers are not usually granted.</p>
</div>
<div class="paragraph">
<p>So you do not need to install bootc on a package mode system about to be reinstalled as an image mode system.
You just run the bootc container image with a specially crafted Podman command which invokes bootc with all required options.</p>
</div>
<div class="paragraph">
<p>The only common scenario for running the bootc utility in a package mode system is reporting that the system was NOT installed as an image mode system.</p>
</div>
<div class="sect2">
<h3 id="_day_1_configuration_using_the_bootc_utility"><a class="anchor" href="#_day_1_configuration_using_the_bootc_utility"></a>Day-1 configuration using the bootc utility</h3>
<div class="paragraph">
<p>The bootc utility was NOT designed to be a stand-alone installation tool for image mode system, but to be invoked by other installation tools such as Anaconda.
The bootc utility is not able to perform typical day-1 customizations, such as network configuration and user passwords.</p>
</div>
<div class="paragraph">
<p>This means any package mode system that is reinstalled as an image mode system by bootc may become completely locked down, with no network configurations and no user passwords nor SSH keys to access it.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Nothing prevents you from building a bootc container image with predefined network settings, such as a static IP address and hostname, or with a user with a known password.
You may want to do that for a quick test, but it is NOT how you are recommended to do for production systems.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The only day-1 configuration which can be provided by the bootc utility itself is setting up SSH keys for the root user.
If you build your bootc container image on the assumption that it takes dynamic network settings from a DHCP server or from cloud-init, then reinstall a cloud instance from it, the cloud instance can be accessed through the root SSH key.</p>
</div>
<div class="paragraph">
<p>Else, you must to provide network settings as kernel arguments, using command-line options of the bootc utility, as part of the Podman command which invokes it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_updating_and_switching_bootc_container_images"><a class="anchor" href="#_updating_and_switching_bootc_container_images"></a>Updating and switching bootc container images</h3>
<div class="paragraph">
<p>In future courses we will also see other uses of the bootc utility:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To check if the current bootc container image installed in a system was updated, and if true, upgrade to the newer image.</p>
</li>
<li>
<p>To switch an image mode system to a different bootc container image, which could serve to "re-purpose" an image mode system to a new role.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A future course will demonstrate how to apply upgrades and switches to image mode system, and the implications of those operations on system settings and application data, along with common strategies for dealing with it.</p>
</div>
<div class="paragraph">
<p>For now, it is just important that you consider that any bootc container images you build now might be applied to systems which already were image mode systems.
You want to somehow distinguish between different versions of the same bootc container image and especially between new versions which were already subject to extensive system and integration testing from others which were not.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_floating_and_fixed_tags"><a class="anchor" href="#_floating_and_fixed_tags"></a>Floating and fixed tags.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What you intuitively know as the <em>name</em> of a container image is actually the name of a <em>repository</em> of container images.
The real ID of a container image is a SHA-256 digest of its image manifest, which lists all layers on the container image and also provides metadata such as labels.</p>
</div>
<div class="paragraph">
<p>In very old container engines, just copying an image between container registries, or from a registry to the local storage of a container engine, would change its ID.
Nowadays, you expect that download (pull) and copy (mirror) operations preserve the IDs of OCI container images.
Using up-to-date container tools, which preserve image IDs, is crucial to support security mechanisms such as container image signatures.</p>
</div>
<div class="paragraph">
<p>A single container image repository could contain hundreds of different images, and each of them is accessible by their own ID.
Each container image in a repository could be completely unrelated to others, not sharing any layers at all.
This is not common, but could be done.</p>
</div>
<div class="paragraph">
<p>Because humans do not like to deal with very long random strings (the SHA-256 digests), images can be tagged, and then you can refer to a specific image by its name and tag pair, that is <code>name:tag</code>.</p>
</div>
<div class="paragraph">
<p>So a name and tag pair links to a specific image ID, but that link could change, like a symbolic link in a Linux file system.
If you expect that a tag links to a new image ID in the future, you call it a <em>floating</em> tag.
The <code>latest</code> tag is an example of a floating tag.</p>
</div>
<div class="paragraph">
<p>If you expect that a tag remains linked to the same image ID forever, you call it a <em>fixed</em> or <em>non-floating</em> tag.
It is common that continuous integration (CI) systems and other automatic build systems assign a fixed tag, based on a sequential build number or a time stamp, to all container images they produce.</p>
</div>
<div class="sect2">
<h3 id="_floating_and_fixed_tags_in_a_ci_pipeline"><a class="anchor" href="#_floating_and_fixed_tags_in_a_ci_pipeline"></a>Floating and fixed tags in a CI pipeline</h3>
<div class="paragraph">
<p>It is also common practice that a set of floating tags map to the latest version of an image, according to semantic versioning, and those tags are updated at the end of a continuous integration pipeline, after an image pass automated tests.</p>
</div>
<div class="paragraph">
<p>For example, consider the following sequence of events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is a floating tag named <code>v1.2</code>, and it now points to the same image that is also tagged as <code>v1.2-3245</code>.</p>
</li>
<li>
<p>You produce a new build of that container image, which is tagged as <code>v1.2-3246</code>.</p>
</li>
<li>
<p>Some test fails with the new build, which is never promoted to a released container image.</p>
</li>
<li>
<p>You produce another build of the same container image, which is tagged as <code>v1.2-3247</code>.</p>
</li>
<li>
<p>That newest build pass all tests, so it is also tagged as the new <code>v1.2</code>.
Now tags <code>v1.2</code> and <code>v1.2-3247</code> link to the same image ID.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similar tagging strategies enable having multiple container images, in different stages of testing, and mirroring to edge sites (or making available to end customers) only the images which were actually released, while enabling different systems to perform different kinds of tests.</p>
</div>
<div class="paragraph">
<p>For example, a container registry named <code>internal.example.com</code> contains all container images produced by CI/CD, and test systems grab images from that registry.</p>
</div>
<div class="paragraph">
<p>Another container registry, named <code>production.example.com</code>, only contains images which pass all tests and are intended to be used in production systems.</p>
</div>
<div class="paragraph">
<p>This second registry would NOT contain all container images that exist in the first one.
Having a consistent tagging scheme enables administrators to take corrective action if mirroring from one registry to the other fails for any reason.</p>
</div>
<div class="paragraph">
<p>These are, in fact, recommended practices for managing application container images, and they apply to bootc container images as well.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the next activity, you will publish a bootc container image for use by integration testings, which are performed using pre-existing VMs with the <code>bootc install</code> command.
After tests, you will you publish the bootc container with a semantic versioning floating tag, as a released image for use by production systems.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Publish Bootc Container Images for Edge Devices</a></span>
  <span class="next"><a href="s2-bootc-install-lab.html">Lab: Publish a Bootc Container in a Private Container Registry</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
